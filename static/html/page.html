<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">

  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="/../css/normalize.css" type="text/css">
    <link rel="stylesheet" href="/../css/page.css" type="text/css">
    <script src="/../js/bundle.min.js" type="text/javascript"></script>
  </head>

  <body class="main">
    <div class="page" id="page">
      <image src="/../image/logo.png" class="logo" />
      <div class="version">
        v1.0.0
      </div>
      <div class="slogan">
        The framework you can trust
      </div>
      <div class="readme">
        <h1 id="page">Page</h1>
        <p><strong>Page</strong> can be described as a base for any applications on top of it with server and client on Node.js. It provides a lot of features and common scenarios for using web. It's completely based on the <a href="https://github.com/Guseyn/async-tree-patern/blob/master/Async_Tree_Patern.pdf">Async Tree Pattern</a> that allows you to customize <strong>Page</strong> in any way you want, you can even throw it away and build other base core for your application.</p>
        <p>In another words, <strong>Page</strong> is just an example of how you can build your application using libraries that are based on <a href="https://github.com/Guseyn/cutie">Cutie</a>.</p>
        <h1 id="basicconcepts">Basic Concepts</h1>
        <ol>
          <li>
            <p><strong>Page Is Not a Framework.</strong> Almost every framework is made with assumption that we live in ideal world, but it's very far from the truth. It's not possible to build something big and stable using <em>magic</em>, which every framework is based on. That's why <strong>Page</strong> is not a framework, it allows you to control the whole behaviour of your application and apply new changes in a explicit way.</p>
          </li>
          <li>
            <p><strong>It's Not Easy to Start Quickly.</strong> First of all you need to get acquainted with <a href="https://github.com/Guseyn/async-tree-patern/blob/master/Async_Tree_Patern.pdf">Async Tree Pattern</a> and it's <a href="https://github.com/Guseyn/cutie">implementation</a>. It allows to build everything using pure approach in OOP. Also you must know how <a href="https://nodejs.org/en/docs/">Node.js</a> works and it's important to understand how non-blockinng i/o works there.</p>
          </li>
          <li>
            <p><strong>But It's Very Easy To Continue.</strong> Ones you've learnt how to use <a href="https://github.com/Guseyn/async-tree-patern/blob/master/Async_Tree_Patern.pdf">Async Tree Pattern</a>, libraries that are based on <a href="https://github.com/Guseyn/cutie">cutie</a> and libraries for <strong>Page</strong>, your life is never will be like before. You'll able to intoduce new changes into your code extremely fast and painless(unlike in other frameworks). </p>
          </li>
          <li>
            <p><strong>No Unnecessary Complexity.</strong> Only <em>html</em>, <em>css</em> and <em>js</em> (<em>server side</em> and <em>browser</em>).</p>
          </li>
          <li>
            <p><strong>Small Core.</strong> <strong>Page</strong> is almost based on little pieces from different libraries that can be easily combined with each other for building appication. It makes <strong>Page</strong> lightweight and easily extensible. </p>
          </li>
        </ol>
        <h1 id="howtostartpagecli">How to Start (page-cli)</h1>
        <p>First of all you need to download this repository to your local machine. You can do it via github or <strong>page-cli</strong>. We suggest you to use the last option, because it also makes building and running of your application much easier.</p>
        <h2 id="installationinstructions">Installation Instructions</h2>
        <ol>
          <li>Clone <em>page-cli</em>: <code>git clone https://github.com/Guseyn/page-cli.git</code></li>
          <li>Go to <em>page-cli</em> directory: <code>cd page-cli</code></li>
          <li>Install npm dependencies there: <code>npm install</code></li>
          <li>Link <code>page</code> command: <code>npm link</code></li>
          <li>Go to the workspace where you want to create your project: <code>cd ../&lt;my-projects&gt;</code></li>
          <li>Create project: <code>page create</code></li>
          <li>Then you'll have to enter some information about your project (<code>Project name</code>, <code>Version</code>, <code>Author</code>, <code>Description</code>, <code>License</code>), you'll get this repository with changed <em>package.json</em> and removed <em>.git</em> directory (so you can bind it to your project on github).</li>
          <li>Go to your project directory: <code>cd &lt;projectName&gt;</code></li>
          <li>Install dependencies: <code>npm install</code></li>
        </ol>
        <h2 id="updateinstructions">Update Instructions</h2>
        <ol>
          <li>Go to your project directory: <code>cd &lt;project_name&gt;</code></li>
          <li>Update version of framework: <code>page update</code>, this command just updates versions of components in your <em>package.json</em></li>
          <li>Install new dependencies: <code>npm install</code></li>
        </ol>
        <h1 id="projectstructure">Project Structure</h1>
        <pre><code class="bash language-bash">├── projectName
│   ├── pages
│   │   ├── **/*.js
│   ├── server
│   │   ├── app
│   │   │   ├── build-app.js 
│   │   │   ├── run-app.js
│   │   ├── custom-calls
│   │   │   ├── executedGruntBuild.js
│   │   ├── CreatedCustomIndex.js
│   │   ├── CustomIndex.js
│   │   ├── CustomIntrnalServerErrorMethod.js
│   │   ├── CustomNotFoundMethod.js
│   │   ├── ExecutedGruntBuild.js
│   │   ├── NotFoundErrorEvent.js
│   │   ├── OnPageStaticJsFilesChangeEvent.js
│   │   ├── OnStaticGeneratorsChangeEvent.js
│   │   ├── OnTemplatesChangeEvent.js
│   │   ├── PrintedToConsolePageLogo.js
│   │   ├── ReloadedBackendOnFailedWorkerEvent.js
│   │   ├── UrlToFSPathMapper.js
│   ├── static
│   │   ├── css
│   │   │   ├── **/*.css
│   │   ├── html
│   │   │   ├── **/*.html
│   │   ├── image
│   │   │   ├── **/*.{jpg,png,..}
│   │   ├── js
│   │   │   ├── **/*.js
│   │   ├── txt
│   │   │   ├── **/*.txt
│   │   ├── ...
│   ├── templates
│   │   ├── **/*.html
│   ├── .babelrc
│   ├── .gitignore
│   ├── config.json
│   ├── Gruntfile.js
│   ├── LICENSE
│   ├── package-lock.json
│   ├── package.json
│   ├── README.md
</code></pre>
        <h2 id="pagesdirectory"><code>pages</code> directory</h2>
        <p>This directory contains js scripts that generate static html pages(they are based on <a href="https://github.com/Guseyn/page-static-generator">page-static-generator library</a>). Generation of static pages is contained in <a href="//TODO:add_link_here">building</a> and <a href="//TODO:add_link_here">running</a> processes.</p>
        <h2 id="serverdirectory"><code>server</code> directory</h2>
        <p>This directory contains server part of the application. It's divided into <a href="//TODO:add_link_here">building</a> and <a href="//TODO:add_link_here">running</a> processes.</p>
        <h2 id="staticdirectory"><code>static</code> directory</h2>
        <p>This directory contains static files, each type of files is stored in the corresponding subdirectory(<code>html</code>, <code>js</code> and so on). You can also add subdirectories for different extensions. Just don't forget to configure it in <a href="//TODO:add_link_here">running process</a>.</p>
        <h2 id="templatesdirectory"><code>templates</code> directory</h2>
        <p>This directory contains html tepmlates(components) for <a href="//TODO:add_link_here">generating pages</a>.</p>
        <h2 id="configjson"><code>config.json</code></h2>
        <p><code>config.json</code> contains all settings of <strong>Page</strong>. Use following async composition for retrieving values from config in the code:</p>
        <pre><code class="js language-js">const { ParsedJSON, Value } = require('@cuties/json');
const { ReadDataByPath } = require('@cuties/fs');

new ParsedJSON(
  new ReadDataByPath('./config.json')
).as('config').after(
  /* 
    now you can use following composition 
      for retrieving concrete value from config
  */
  new Value(as('config'), 'somePropertyName')
).call();
</code></pre>
        <h3 id="propertiesinconfigjson">Properties in <code>config.json</code></h3>
        <h4 id="page-1">page</h4>
        <pre><code class="json language-json">"page": {
  "version": "1.0.0",
  "logoText": "./static/txt/logo.txt",
  "logoImage": "./static/image/logo.png",
  "logoImageSrc": "/../image/logo.png"
}
</code></pre>
        <p>This property contains object with information about <strong>Page</strong>: current version, path to the logo in the text format and image format, also image address of the logo.</p>
        <h4 id="indexindexhref">index, indexHref</h4>
        <p>These properties point to the index page. <code>index</code> is for location of the index page in the file system and <code>indexHref</code> is for link address of the index page.</p>
        <h4 id="static">static</h4>
        <p>This property is for location of the directory of static files.</p>
        <h4 id="staticgenerators">staticGenerators</h4>
        <p>This property is for location of the directory with <a href="TODO://add_link_here_about_them">static genrators</a>.</p>
        <h4 id="templates">templates</h4>
        <p>This property is for location of the directory with <a href="TODO://add_link_here_about_them">templates</a>.</p>
        <h4 id="statichtml">staticHtml</h4>
        <p>This property is for location of the directory of static files with <code>html</code> extension.</p>
        <h4 id="staticjs">staticJs</h4>
        <p>This property is for location of the directory of static files with <code>js</code> extension (<em>es6</em>).</p>
        <h4 id="outstaticjs">outStaticJs</h4>
        <p>This property is for location of the directory of static files with <code>js</code> extension(for using in a browser).</p>
        <h4 id="bundle">bundle</h4>
        <p>This property is for location of the bundle file that is generated from <code>outStaticJs</code> directory.</p>
        <h4 id="bundlehref">bundleHref</h4>
        <p>This property is for link of the bundle file.</p>
        <h4 id="minbundle">minBundle</h4>
        <p>This property is for location of the minified version of the bundle file.</p>
        <h4 id="minbundlehref">minBundleHref</h4>
        <p>This property is for link of the minified bundle file.</p>
        <h4 id="enviromentslocalproddevstageprod">enviroments(local, prod, dev, stage, prod)</h4>
        <p>Every environment property includes <code>protocol, port, host, clusterMode</code>. You can also add your own environments and environment properties (for example, if you use <code>https</code> for <code>protocol</code>, you might need <code>cert</code> and <code>key</code> properties).</p>
        <pre><code class="json language-json">"local": {
  "protocol": "http",
  "port": 8000,
  "host": "127.0.0.1",
  "clusterMode": true
},
"dev": {
  "protocol": "http",
  "port": 8000,
  "host": "127.0.0.1",
  "clusterMode": true
},
"test": {
  "protocol": "http",
  "port": 8000,
  "host": "127.0.0.1",
  "clusterMode": true
},
"stage": {
  "protocol": "http",
  "port": 8000,
  "host": "127.0.0.1",
  "clusterMode": true
},
"prod": {
  "protocol": "http",
  "port": 8000,
  "host": "127.0.0.1",
  "clusterMode": true
}
</code></pre>
        <h1 id="buildingprocess">Building process</h1>
        <p>The declaration of this process is in <a href="https://github.com/Guseyn/page/blob/master/server/app/build-app.js">server/app/build-app.js</a> script. Here we execute <a href="https://github.com/Guseyn/page/blob/master/Gruntfile.js">grunt build</a> (you can use other build system). After grunt tasks are executed we generate static pages. And that's it, you can also add some other steps in your building process.</p>
        <p>For building use command: <code>page build [evironment]</code> or <code>page b [evironment]</code>. <code>environment</code> is one of the following values: <code>local</code>, <code>prod</code>, <code>dev</code>, <code>stage</code>, <code>prod</code> (<code>local</code> is default).</p>
        <pre><code class="js language-js">// server/app/build-app.js

const { as } = require('@cuties/cutie');
const { ProcessWithExitEvent, KilledProcess } = require('@cuties/process');
const { ParsedJSON, Value } = require('@cuties/json');
const { ExecutedScripts } = require('@cuties/scripts');
const { ReadDataByPath } = require('@cuties/fs');
const PrintedToConsolePageLogo = require('./../PrintedToConsolePageLogo');
const ExecutedGruntBuild = require('./../ExecutedGruntBuild');
const env = process.env.NODE_ENV || 'local';

new ParsedJSON(
  new ReadDataByPath('./config.json')
).as('config').after(
  new PrintedToConsolePageLogo(
    new ReadDataByPath(
      new Value(as('config'), 'page.logoText')
    ),
    new Value(as('config'), 'page.version'),
    `BUILD (${env})`
  ).after(
    new ExecutedGruntBuild(process).after(
      new ExecutedScripts(
        new Value(as('config'), 'staticGenerators')
      )
    )
  )
).call();
</code></pre>
        <p>So, here building process just generates static pages and minified bundle js file as it's shown <a href="(https://github.com/Guseyn/page/blob/master/Gruntfile.js">here</a>).</p>
        <h1 id="runningprocess">Running process</h1>
        <p>The declaration of this process is in <a href="https://github.com/Guseyn/page/blob/master/server/app/run-app.js">server/app/run-app.js</a> script.</p>
        <h2 id="backendserver">Backend (server)</h2>
        <p>For building backend server with REST API we use here <a href="https://github.com/Guseyn/cutie-rest">cutie-rest</a>:</p>
        <pre><code class="js language-js">const launchedBackend = new Backend(
  new Value(as('config'), `${env}.protocol`),
  new Value(as('config'), `${env}.port`),
  new Value(as('config'), `${env}.host`),
  new RestApi(
    new CreatedCustomIndex(
      new Value(as('config'), 'index'),
      notFoundMethod
    ),
    new CreatedServingFilesMethod(
      new RegExp(/^\/(css|html|image|js|txt)/),
      new UrlToFSPathMapper(
        new Value(as('config'), 'static')
      ),
      notFoundMethod
    ),
    notFoundMethod,
    internalServerErrorMethod
  )
);
</code></pre>
        <p>It's just an example of how it could be built and work. But, of course, you can configure it differently due to your requirements.</p>
        <p>For running use command: <code>page run [evironment]</code> or <code>page r [evironment]</code>. <code>environment</code> is one of the following values: <code>local</code>, <code>prod</code>, <code>dev</code>, <code>stage</code>, <code>prod</code> (<code>local</code> is default).</p>
        <p>As you can see here, we get some parameters like <code>post</code> and <code>host</code> from <code>config.json</code>. If look at the whole script, you can notice that it's possible to run server in <a href="https://nodejs.org/dist/latest/docs/api/cluster.html">cluster mode</a>.</p>
        <h2 id="thewholedeclaration">The whole declaration</h2>
        <p>I believe that the declarative code below is self-explainable, but you can anyway <a href="https://github.com/Guseyn/page/issues">submit an issue</a>, if something is not clear. However, it requires some knowledge in such modules like: <a href="https://github.com/Guseyn/cutie">cutie</a>, <a href="https://github.com/Guseyn/cutie-if-else">cutie-if-else</a>, <a href="https://github.com/Guseyn/cutie-cluster">cutie-cluster</a>, <a href="https://github.com/Guseyn/cutie-json">cutie-json</a>, <a href="https://github.com/Guseyn/cutie-rest">cutie-rest</a>, <a href="https://github.com/Guseyn/cutie-fs">cutie-fs</a>.</p>
        <pre><code class="js language-js">const cluster = require('cluster');
const { as } = require('@cuties/cutie');
const { If, Else } = require('@cuties/if-else');
const { IsMaster, ClusterWithForkedWorkers, ClusterWithExitEvent } = require('@cuties/cluster');
const { ParsedJSON, Value } = require('@cuties/json');
const { Backend, RestApi, CreatedServingFilesMethod, CreatedCachedServingFilesMethod } = require('@cuties/rest');
const { ReadDataByPath, WatcherWithEventTypeAndFilenameListener } = require('@cuties/fs');
const CustomNotFoundMethod = require('./../CustomNotFoundMethod');
const CustomInternalServerErrorMethod = require('./../CustomInternalServerErrorMethod');
const CreatedCustomIndex = require('./../CreatedCustomIndex');
const OnPageStaticJsFilesChangeEvent = require('./../OnPageStaticJsFilesChangeEvent');
const OnStaticGeneratorsChangeEvent = require('./../OnStaticGeneratorsChangeEvent');
const OnTemplatesChangeEvent = require('./../OnTemplatesChangeEvent');
const ReloadedBackendOnFailedWorkerEvent = require('./../ReloadedBackendOnFailedWorkerEvent');
const UrlToFSPathMapper = require('./../UrlToFSPathMapper');
const PrintedToConsolePageLogo = require('./../PrintedToConsolePageLogo');
const notFoundMethod = new CustomNotFoundMethod(new RegExp(/^\/not-found/));
const internalServerErrorMethod = new CustomInternalServerErrorMethod();
const numCPUs = require('os').cpus().length;
const env = process.env.NODE_ENV || 'local';
const dev_env = env === 'local' || env === 'dev';

const launchedBackend = new Backend(
  new Value(as('config'), `${env}.protocol`),
  new Value(as('config'), `${env}.port`),
  new Value(as('config'), `${env}.host`),
  new RestApi(
    new CreatedCustomIndexMethod(
      new Value(as('config'), 'index'),
      notFoundMethod
    ),
    new CreatedServingFilesMethod(
      new RegExp(/^\/(css|html|image|js|txt)/),
      new UrlToFSPathMapper(
        new Value(as('config'), 'static')
      ),
      notFoundMethod
    ),
    notFoundMethod,
    internalServerErrorMethod
  )
);

new ParsedJSON(
  new ReadDataByPath('./config.json')
).as('config').after(
  new If(
    new IsMaster(cluster),
    new PrintedToConsolePageLogo(
      new ReadDataByPath(
        new Value(as('config'), 'page.logoText')
      ),
      new Value(as('config'), 'page.version'),
      `RUN (${env})`
    ).after(
      new If(
        dev_env,
        new WatcherWithEventTypeAndFilenameListener(
          new Value(as('config'), 'staticGenerators'),
          { persistent: true, recursive: true, encoding: 'utf8' },
          new OnStaticGeneratorsChangeEvent(
            new Value(as('config'), 'staticGenerators')
          )
        ).after(
          new WatcherWithEventTypeAndFilenameListener(
            new Value(as('config'), 'templates'),
            { persistent: true, recursive: true, encoding: 'utf8' },
            new OnTemplatesChangeEvent(
              new Value(as('config'), 'staticGenerators')
            )
          ).after(
            new WatcherWithEventTypeAndFilenameListener(
              new Value(as('config'), 'staticJs'),
              { persistent: true, recursive: true, encoding: 'utf8' },
              new OnPageStaticJsFilesChangeEvent(
                new Value(as('config'), 'staticJs'),
                new Value(as('config'),'bundleJs')
              )
            )
          )
        )
      ).after(
        new If(
          new Value(as('config'), `${env}.clusterMode`),
          new ClusterWithForkedWorkers(
            new ClusterWithExitEvent(
              cluster,
              new ReloadedBackendOnFailedWorkerEvent()
            ), numCPUs
          ),
          new Else(
            launchedBackend
          )
        )
      )
    ),
    new Else(
      launchedBackend
    )
  )
).call();
</code></pre>
        <p>As you can see it's easily configurable code, so you can add and remove components due to your requirements.</p>
        <p>In few words, running process here runs server with REST API (in cluster mode by default) and adds <a href="https://nodejs.org/dist/latest/docs/api/fs.html#fs_fs_watch_filename_options_listener">fs watchers</a> on <code>pages</code>, <code>static</code>, <code>templates</code> directories(in <code>local</code> and <code>dev</code> environments). Also in cluster mode failed processes restart automatically.</p>
        <h1 id="listoflibrariesforpage">List of libraries for Page</h1>
        <p>All these libraries are available on <strong>npm</strong> under <code>@page-libs</code> scope.</p>
        <h2 id="pagecutie">page-cutie</h2>
        <p><a href="https://github.com/Guseyn/page-cutie">This library</a> is analogue of <a href="https://github.com/Guseyn/cutie">cutie</a> for using <a href="https://github.com/Guseyn/async-tree-patern/blob/master/Async_Tree_Patern.pdf">Async Tree Pattern</a> in browser.</p>
        <p><strong>Warning:</strong> If you want to use async objects from libraries that are based on <a href="https://github.com/Guseyn/cutie">cutie</a> in browser, you must change their parents from <code>AsyncObject</code> in <strong>cutie</strong> to the <code>AsyncObject</code> from <strong>page-cutie</strong>. Use following function:</p>
        <pre><code class="js language-js">const AsyncObject = require('@cuties/cutie').AsyncObject;
const PageAsyncObject = require('@page-libs/cutie').AsyncObject;

function transformedAsyncObjects(...asyncObjects) {
  for (let i = 0; i &lt; asyncObjects.length; i++) {
    if (asyncObjects[i].prototype instanceof PageAsyncObject) {
      Object.setPrototypeOf(asyncObjects[i].prototype, AsyncObject.prototype);
      Object.setPrototypeOf(asyncObjects[i], AsyncObject);
    }
  }
  return asyncObject;
}
</code></pre>
        <h2 id="pageajax">page-ajax</h2>
        <p><a href="https://github.com/Guseyn/page-cutie">This library</a> allows you to use ajax in very conviniet way. It works like external request objects in <a href="https://github.com/Guseyn/cutie-http">cutie-http</a> or <a href="https://github.com/Guseyn/cutie-https">cutie-https</a>.</p>
        <h3 id="example">Example</h3>
        <pre><code class="js language-js">new ResponseBody(
  new ResponseFromAjaxRequest({
    url: 'http://localhost:8000/html/res.html',
    method: 'GET'
  })
).call();
</code></pre>
        <p>So, as you can see here, it's possible wrap async request with just one object using <a href="https://github.com/Guseyn/async-tree-patern/blob/master/Async_Tree_Patern.pdf">Async Tree Pattern</a>.</p>
        <h2 id="pageunit">page-unit</h2>
        <p><a href="https://github.com/Guseyn/page-unit">This library</a> allows you to represent <em>html code</em> as <em>js code</em>, so you can encapsulate entire behaviour of DOM elements in objects.</p>
        <h3 id="example-1">Example</h3>
        <p>We can represent following html code:</p>
        <pre><code class="html language-html">&lt;div id="user-form"&gt;
  &lt;input id ="name"&gt;
  &lt;input id ="password"&gt;
  &lt;button id="submit"&gt;Sign in&lt;/button&gt;
&lt;/div&gt;
</code></pre>
        <p>like this composition:</p>
        <pre><code class="js language-js">new UserForm(
  document.getElementById('user-form'), 
  new NameInput(document.getElementById('name')),
  new PasswordInput(document.getElementById('password')),
  new SubmitButton(document.getElementById('submit'))
);
</code></pre>
        <p>Full example <a href="https://github.com/Guseyn/page-unit#example">here</a>.</p>
        <h2 id="pagestaticgenerator">page-static-generator</h2>
        <p><a href="https://github.com/Guseyn/page-static-generator">This library</a> is simple tool for generating <em>html</em> pages from different templates combining them.</p>
        <h3 id="example-2">Example</h3>
        <p>We can build <em>html</em> page from these two templates:</p>
        <pre><code class="html language-html">&lt;!-- outer.html --&gt;
&lt;div class="outer"&gt;
   {text}
  &lt;div class="place-for-inner-template"&gt;
    {innerTemplate}
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
        <pre><code class="html language-html">&lt;!-- inner.html --&gt;
&lt;div class="inner"&gt;
   {text}
&lt;/div&gt;
</code></pre>
        <p>using following composition:</p>
        <pre><code class="js language-js">'use strict'

const { SavedPage, PrettyPage, Page, Head, Body, Script, Style, TemplateWithParams, Template } = require('@page-libs/static-generator');

new SavedPage(
  'page.html', 
  new PrettyPage(
    new Page(
      'xmlns="http://www.w3.org/1999/xhtml" lang="en"',
      new Head(
        new Script('script1.js', 'type="text/javascript"'),
        new Script('script2.js', 'type="text/javascript"'),
        new Style('main.css', 'type="text/css"'),
        new Style('mobile.css', 'type="text/css"')
      ),
      new Body(
        'class="main"',
        new TemplateWithParams(
          new Template('outer.html'),
          'text in outer template',
          new TemplateWithParams(
            new Template('inner.html'),
            'text in inner template'
          )
        )
      )
    )
  )
).call();
</code></pre>
        <p>The result is</p>
        <pre><code class="html language-html">&lt;!-- page.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" lang="en"&gt;

  &lt;head&gt;
    &lt;script src="script1.js" type="text/javascript"&gt;&lt;/script&gt;
    &lt;script src="script2.js" type="text/javascript"&gt;&lt;/script&gt;
    &lt;link rel="stylesheet" href="main.css" type="text/css"&gt;
    &lt;link rel="stylesheet" href="mobile.css" type="text/css"&gt;
  &lt;/head&gt;

  &lt;body class="main"&gt;
    &lt;div class="outer"&gt;
      text in outer template
      &lt;div class="place-for-inner-template"&gt;
        &lt;div class="inner"&gt;
          text in inner template
        &lt;/div&gt;

      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;

&lt;/html&gt;
</code></pre>
        <p>You can find more information about usage <a href="https://github.com/Guseyn/page-static-generator#usage">here</a>.</p>
      </div>
      <button id="button">
        click
      </button>
    </div>
  </body>

</html>
